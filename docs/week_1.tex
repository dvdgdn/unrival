% Created 2025-09-23 Tue 16:28
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{graphicx}
\author{Your Software Pedagogue}
\date{\today}
\title{Promise Protocol v1 ‚Äî The Guided Tour\\\medskip
\large Week 1 of 12: The Workshop \& Primitives}
\hypersetup{
 pdfauthor={Your Software Pedagogue},
 pdftitle={Promise Protocol v1 ‚Äî The Guided Tour},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 30.1 (Org mode 9.7.11)}, 
 pdflang={English}}
\begin{document}

\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\section{This Week's Mission üéØ}
\label{sec:orgf39c3c6}
The goal this week is to lay a rock-solid foundation for the entire project. We will not build any user-facing features. Instead, we will build the "factory" that will produce those features. By the end of this week, you will have a fully automated development environment and a set of core, trustworthy tools that will prevent entire classes of bugs in the weeks to come. This is the most important investment you can make in the project's long-term health and your own development speed.
\section{Learning Plan üìö}
\label{sec:org44896b1}
This week's reading is the largest block, but it provides the essential context for everything that follows. It covers how services communicate and how we operate them.
\subsection{{\bfseries\sffamily TODO} Reading Assignment}
\label{sec:org4fcebbb}
\begin{itemize}
\item[{$\square$}] Read \textbf{Part I: Communication (Ch 2-5)} in \emph{Understanding Distributed Systems}.
\begin{itemize}
\item \textbf{Focus On}: REST principles, HTTP methods/status codes, and especially \textbf{Section 5.7: Idempotency}.
\end{itemize}
\item[{$\square$}] Read \textbf{Part V: Maintainability (Ch 29-33)} in \emph{Understanding Distributed Systems}.
\begin{itemize}
\item \textbf{Focus On}: The "Test Pyramid" (\textbf{\textbf{Ch 29}}), CI/CD pipeline stages (\textbf{\textbf{Ch 30}}), and the difference between metrics, logs, and traces (\textbf{\textbf{Ch 31-32}}).
\end{itemize}
\end{itemize}
\section{Building Plan: A Step-by-Step Guide üõ†Ô∏è}
\label{sec:org284168a}
Work through these top-level `TODO` items in order. Use the checklists to track your progress on the sub-tasks.
\subsection{{\bfseries\sffamily TODO} Step 1.1: Set up the Monorepo \& Workspace}
\label{sec:org1297e74}
This first task is to create the physical layout for our code. We'll use a monorepo because it makes sharing code between our services (like the API and the web frontend) much simpler.

\begin{itemize}
\item[{$\square$}] Create the root project folder and initialize a Git repository.
\item[{$\square$}] Create the core folder structure: \texttt{apps/}, \texttt{packages/}, and \texttt{infra/}.
\item[{$\square$}] Initialize a package manager workspace (e.g., using `npm workspaces` or `pnpm`).
\end{itemize}
\subsection{{\bfseries\sffamily TODO} Step 1.2: Implement the CI Pipeline \& Health Check}
\label{sec:org57ac915}
Before we write any real code, we'll write a test that proves our automation works. This test is simple, but it will validate our entire CI/CD pipeline. The goal is to have a pull request automatically trigger a process that builds, deploys, and tests our application in a temporary, isolated environment.

\begin{itemize}
\item[{$\square$}] Create a barebones API application in \texttt{apps/api} with a single \texttt{/health} endpoint that returns "ok".
\item[{$\square$}] Write the Gherkin feature file for the pipeline test in your acceptance test suite.
\begin{verbatim}
Feature: Platform Health and CI Pipeline

  Scenario: The CI pipeline can build, deploy, and test the application
    When a change is pushed to a pull request
    Then the CI pipeline should run successfully
    And deploy the application to a temporary "ephemeral" environment
    And run an acceptance test against the ephemeral environment's "/health" endpoint
    And the test should receive a 200 OK response with the body "ok"
\end{verbatim}
\item[{$\square$}] Create the CI configuration file (e.g., `.github/workflows/ci.yml`) with stages for linting, testing, building, deploying, and acceptance testing.
\begin{verbatim}
name: ci
on: [pull_request]
jobs:
  lint_unit:
    # ... steps to checkout, install, lint, and run unit tests
  build:
    # ... steps to build a Docker image
  deploy_ephemeral:
    # ... steps to run a script that deploys the Docker image to a temporary environment
  acceptance_test:
    needs: deploy_ephemeral
    # ... steps to run the acceptance test against the ephemeral URL
\end{verbatim}
\item[{$\square$}] Write the single acceptance test described in the Gherkin scenario.
\end{itemize}
\subsection{{\bfseries\sffamily TODO} Step 1.3: Enforce the Layered Architecture}
\label{sec:org29d7116}
Now we enforce the "Clean Workshop" principle. We'll add an automated rule to prevent dependencies from crossing the architectural layers incorrectly. This is an application of the \textbf{Dependency Inversion Principle}: our business logic should not depend on technical details; the details should depend on the business logic.

\begin{itemize}
\item[{$\square$}] Install a dependency analysis tool like `dependency-cruiser`.
\item[{$\square$}] Create a rule that makes it an error for your `domain` package to import anything from your `infrastructure` package.
\begin{verbatim}
// .dependency-cruiser.js
module.exports = {
  forbidden: [
    {
      name: "domain-must-be-pure",
      severity: "error",
      from: { path: "^packages/domain" },
      to: { path: "^packages/infrastructure" } // Or any other layer
    },
    // ... other rules
  ]
};
\end{verbatim}
\item[{$\square$}] Run the check in your CI pipeline's `lint\_unit` job to enforce the rule automatically.
\end{itemize}
\subsection{{\bfseries\sffamily TODO} Step 1.4: Build the Core Primitives}
\label{sec:org9be5daa}
Finally, we build the core, reusable tools that will protect us from common bugs. These are \textbf{Value Objects}: small, immutable objects defined by their value, not their identity. They are like perfectly calibrated wrenches that you can always trust.
\subsubsection{{\bfseries\sffamily TODO} Build the `Money` Primitive}
\label{sec:org868ce5e}
\textbf{The Problem}: Computers are famously bad at floating-point math (e.g., in JavaScript, \texttt{0.1 + 0.2} is not \texttt{0.3}). Handling money with floats will lead to rounding errors.
\textbf{The Solution}: We will represent all monetary values as integers of the smallest currency unit (e.g., cents). Our `Money` object will encapsulate this logic.

\begin{itemize}
\item[{$\square$}] Create a `Money` class in \texttt{packages/domain/shared/money.ts}.
\item[{$\square$}] Store the amount as a private integer (`amountInCents`).
\item[{$\square$}] Add immutable methods like `add(other: Money)`, `subtract(other: Money)`, and `multiply(factor: number)`, which must \textbf{return a new Money object}.
\item[{$\square$}] Write comprehensive, table-driven unit tests to cover all financial scenarios.
\begin{verbatim}
Feature: Money Value Object

  Scenario Outline: Money math is always correct
    Given money <amount1>
    And money <amount2>
    When I <operation> them
    Then the result is <expected>

    Examples:
      | amount1 | operation | amount2 | expected |
      | ‚Ç¨10.00  | add       | ‚Ç¨5.00   | ‚Ç¨15.00   |
      | ‚Ç¨10.00  | subtract  | ‚Ç¨5.50   | ‚Ç¨4.50    |
      | ‚Ç¨1.10   | multiply  | 1.5     | ‚Ç¨1.65    |
\end{verbatim}
\end{itemize}
\subsubsection{{\bfseries\sffamily TODO} Build the `Clock` Primitive}
\label{sec:org813e5f9}
\textbf{The Problem}: Code that calls `Date.now()` is impossible to test reliably for time-sensitive logic. You can't fast-forward, rewind, or freeze time.
\textbf{The Solution}: We treat time as an external dependency. We define a `Clock` interface and "inject" it wherever we need the current time. For production, we use a `SystemClock`; for tests, we use a `FixedClock`.

\begin{itemize}
\item[{$\square$}] Create a `Clock` interface in \texttt{packages/domain/shared/clock.ts}.
\begin{verbatim}
export interface Clock {
  now(): Date;
}
\end{verbatim}
\item[{$\square$}] Create a `SystemClock` that implements the interface by calling `new Date()`.
\item[{$\square$}] Create a `FixedClock` that takes a `Date` in its constructor and always returns that same date.
\item[{$\square$}] Write a unit test that uses the `FixedClock` to test a piece of time-sensitive logic.
\begin{verbatim}
// Example of a unit test using the FixedClock
it('should do something at a specific time', () => {
  const frozenTime = new Date('2025-10-10T10:00:00Z');
  const clock = new FixedClock(frozenTime);

  // Pass the clock to the object under test
  const myService = new MyTimeSensitiveService({ clock });

  // ... run the test
});
\end{verbatim}
\end{itemize}
\end{document}

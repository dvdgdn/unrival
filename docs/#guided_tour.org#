#+TITLE: Promise Protocol v1 — The Guided Tour
#+SUBTITLE: An Integrated 12-Week Learning & Delivery Plan
#+AUTHOR: Your Software Pedagogue
#+DATE: 2025-09-17
#+LANGUAGE: en
#+OPTIONS: toc:3 num:t ^:nil

* How to use this plan
This document is your single source of truth for building the Promise Protocol. It merges a practical, 12-week delivery schedule with a deep, prerequisite-aware learning curriculum based on Roberto Vitillo's /Understanding Distributed Systems/.

The plan is designed around two core principles:
1.  *Build Vertically*: We will deliver value in "vertical slices," building one complete, end-to-end feature at a time. This is like building a skyscraper one fully-finished apartment at a time, allowing you to get feedback early and often.
2.  *Learn Horizontally*: We will acquire knowledge in logical layers. This is like learning all about a skyscraper's foundation before learning about its steel frame.

This plan balances these two priorities, ensuring you learn the right concepts just in time to build the next feature with confidence and depth. Each week contains clear *Learning Goals* and *Building Goals*.

* Phase 1: The Core Transaction (Weeks 1-4)
**Goal**: At the end of this month, you will have a working, reliable, end-to-end system that can successfully take a booking, authorize a deposit with a real payment provider, and correctly decide on the final settlement. This is your MVP.

*** Week 1: The Workshop & Primitives
- *This Week's Goal*: To build a clean, automated "workshop" for your project and forge the fundamental, trustworthy tools you'll use everywhere.
- *Learning Goals*:
  - Read *Part I: Communication (Ch 2-5)* and *Part V: Maintainability (Ch 29-33)* from /Understanding Distributed Systems/.
  - /Why this now?/: This front-loads the absolute essentials. [cite_start]Part I covers the "physics" of how services talk, and Part V covers the operational lifecycle (testing, deploying, monitoring)[cite: 11, 23]. Reading these first gives you the complete context for building a professional-grade system from day one.
- *Building Goals*:
  - (Original Steps 0 & 1) Set up your monorepo, a CI pipeline that runs on every commit, and scripts for deploying ephemeral environments per pull request.
  - Build the core, pure primitives in your domain package: `Money` (using integer cents), `Percentage`, and a controllable `Clock`.
  - Establish your "layered architecture" with linting rules to enforce boundaries.
- *Key Concepts Deep Dive*:
  - *Layered Architecture*: A strict set of rules for organizing code to prevent a "spaghetti" mess. [cite_start]The most important rule is that the business logic (Domain) must be pure and never depend on technical details like a database or a web framework[cite: 194, 195].
  - [cite_start]*CI/CD (Continuous Delivery)*: The practice of automating the entire process of releasing code, from code review to production deployment, to make releases safe and efficient[cite: 3385].

**** Supplementary Reading
- sets
- well-ordering
- induction  
*** Week 2: The First Booking
- *This Week's Goal*: To bring the system to life by handling its first real user action: booking a session.
- *Learning Goal*:
  - Read *Chapter 12: Transactions*.
  - [cite_start]/Why this now?/: To understand the *ACID guarantees* (Atomicity, Consistency, Isolation, Durability) that your relational database provides when you save that first session record[cite: 1703].
- *Building Goals*:
  - (Original Step 2) Define your first BDD feature test for creating a session.
#+BEGIN_SRC gherkin
Feature: Book a coaching session
  Scenario: Client books a 60-minute session
    When I POST "/sessions" with price €110, deposit 50%, start "2025-10-10T10:00:00Z"
    Then I receive 201 with a sessionId
    And the session exists in the database in state "BOOKED"
#+END_SRC
  - Implement the `POST /sessions` API endpoint, DTO validation, Application service, Domain aggregate (`Session`), and Repository to make the test pass.
**** Supplementary Reading
- sets
- induction
- well-ordering    
*** Week 3: The Money Moves
- *This Week's Goal*: To tackle the highest-risk part of the project by integrating with a real payment provider and building the time-based job to authorize a deposit.
- *Learning Goal*:
  - Read *Chapter 27: Downstream resiliency*.
  - [cite_start]/Why this now?/: To master the critical patterns of *Timeouts*, *Retries*, and *Circuit Breakers* just as you're about to connect to a real, unreliable external service[cite: 3019].
- *Building Goals*:
  - (Original Steps 3 & 5) Integrate with the *Stripe/PayPal sandbox*.
  - Build the `T-48h` authorization job that reads from a `scheduled_jobs` table.
  - Implement a resilient PSP gateway that uses timeouts, retries with jittered backoff, and a circuit breaker.
  - [cite_start]Ensure the authorization call is fully *idempotent* by generating and using an idempotency key[cite: 844].
**** Supplementary Reading
- relations 
*** Week 4: The Judgment
- *This Week's Goal*: To build the pure "brain" of your financial logic, focusing on correctness and testability.
- *Learning Goal*: No new reading. Consolidate your knowledge from the first three weeks and apply your understanding of testing from *Chapter 29*.
- *Building Goals*:
  - (Original Step 4) Build the pure `SettlementPolicy` object.
  - Model your business rules (cancellation windows, rebates) as a *decision table* first, then implement them as a pure function.
  - Write comprehensive, table-driven unit tests to cover every financial scenario.
**** Supplementary Reading
- relations
* Phase 2: The Evidence & Intelligence Layer (Weeks 5-8)
**Goal**: With the core transaction working, this phase adds the "smarts" by ingesting evidence and building the scoring logic.

*** Week 5: The Listening Post
- *This Week's Goal*: To securely and reliably ingest data from an external system (Zoom) via webhooks.
- *Learning Goals*:
  - Read *Chapter 13.1 (Outbox pattern)* and *Chapter 7 (Failure detection)*.
  - /Why this now?/: The Outbox pattern is needed for reliably processing the result of an incoming webhook. Failure Detection introduces core resiliency concepts that are good to learn now.
- *Building Goals*:
  - (Original Step 6) Build the webhook ingestion endpoint.
  - [cite_start]Implement *HMAC signature verification* to ensure the webhook is authentic[cite: 475].
  - Implement *deduplication* logic to safely ignore duplicate events.

*** Week 6: The Theoretical Foundation, Part 1
- *This Week's Goal*: To build the first part of the intelligence layer while acquiring the necessary theoretical foundation for the rest of the phase.
- *Learning Goals*:
  - Read *Chapter 8 (Time)* and *Chapter 9 (Leader election)*.
  - /Why this now?/: These chapters are the direct prerequisites for understanding replication. You must learn them in order to grasp the concepts in the following weeks.
- *Building Goals*:
  - (Original Step 7) Build the safe, sandboxed *DSL* (Domain-Specific Language) and the Assessment Engine.
**** Supplementary Reading
- machines
- automata  
*** Week 7: The Living Scorecard & Replication
- *This Week's Goal*: To build the dynamic scorecard and complete your understanding of distributed consensus.
- *Learning Goal*:
  - Read *Chapter 10 (Replication)*.
  - /Why this now?/: With the prerequisites from last week complete, you can now fully grasp *State Machine Replication*. [cite_start]You will see that your DSL Assessment Engine must be *deterministic*, just like the operations in this model[cite: 1253].
- *Building Goals*:
  - (Original Step 8) Build the `Scorecard` aggregate with its methods to apply deltas, decay over time, and handle monthly forgiveness.

*** Week 8: The Full Picture
- *This Week's Goal*: To complete the scoring logic by composing multiple inputs into a single, confidence-aware score.
- *Learning Goal*:
  - Read *Chapter 11 (Coordination avoidance)*.
  - /Why this now?/: This chapter on weaker consistency models and CRDTs provides the theoretical context for why you might hide a score until you have a "minimum sample size" to be confident in it.
- *Building Goals*:
  - (Original Step 9) Add the final standards (e.g., "Recap ≤24h").
  - Implement the logic to compose the Overall Awesome Score (OAS) using weighted sums.
  - Implement the display rules to hide the OAS until the minimum evidence threshold is met.

* Phase 3: The Trust & Hardening Layer (Weeks 9-12)
**Goal**: To build the final user-trust features and make the entire system ready for a public, production launch.

*** Week 9: The Vault
- *This Week's Goal*: To become a responsible custodian of your users' most sensitive data.
- *Learning Goal*:
  - Read *Chapter 22 (Control planes and data planes)*.
  - /Why this now?/: This provides a powerful mental model for thinking about user consent as a "configuration" (managed by a control plane) that your data processing services (the data plane) must obey.
- *Building Goals*:
  - (Original Step 10) Build the consent gates to block sensitive evidence without explicit opt-in.
  - Build the DSAR export and data retention/purge jobs.

*** Week 10: The Safety Net
- *This Week's Goal*: To build the systems for transparency and human-in-the-loop correction.
- *Learning Goal*:
  - Read *Chapter 13.2 (Sagas)*.
  - [cite_start]/Why this now?/: The "compensating transaction" model from Sagas is the perfect theoretical parallel for an admin appeal that corrects a previous automated system action[cite: 1917].
- *Building Goals*:
  - (Original Steps 11 & 12) Build the Transparency Page with its "explainer" payloads and user-controlled weights. Build the Appeals Console and the workflow for admin adjustments.

*** Week 11: Production Readiness
- *This Week's Goal*: To build the hardened, scalable, and reliable cloud infrastructure for the application.
- *Learning Goal*:
  - Read all of *Part III (Scalability, Ch 14-23)* and *Part IV (Resiliency, Ch 24-28)*.
  - /Why this now?/: This is the capstone reading, where you connect all the theory to the real-world infrastructure you are now building (load balancers, caching, fault isolation, etc.).
- *Building Goals*:
  - (Original Step 13) Write the Terraform code (Infrastructure as Code) for all cloud resources.
  - Configure Kubernetes for deployment and scaling.
  - Set up your core observability stack: metrics, logs, traces, and dashboards.
  - Implement zero-downtime blue/green deployments.

*** Week 12: Drills, Polish & Buffer
- *This Week's Goal*: To validate your hardened system, finalize documentation, and absorb any project delays.
- *Learning Goal*:
  - Read *Chapter 24 (Common failure causes)*.
  - /Why this now?/: To get a checklist of what kind of failures to simulate during your disaster drills.
- *Building Goals*:
  - Run disaster drills: intentionally trigger failures (e.g., block access to the PSP, shut down database replicas) and follow your runbooks to see if the system behaves as expected.
  - Finalize all documentation.
  - Address any bugs or "polish" items discovered during hardening.

* Appendix: The Five Big Ideas
A quick reference for the core, cross-cutting principles you will master during this project.

- *1. The Clean Workshop (Layered Architecture)*
  - *What*: A strict organization of code into layers (Presentation, Application, Domain, Infrastructure) where dependencies only point inwards.
  - [cite_start]*Why*: Prevents a "spaghetti" mess and keeps the core business logic (Domain) pure and independent of technical details[cite: 194, 195].

- *2. Trustworthy Tools (Value Objects)*
  - *What*: Creating your own ultra-safe data types (like `Money` or `Clock`) instead of using generic ones.
  - *Why*: To eliminate entire categories of bugs related to things like floating-point math errors or unpredictable system time.

- *3. The Unreliable World (Resilience Patterns)*
  - *What*: A set of defensive techniques for dealing with network failures and messy external systems, including Idempotency, Retries, and Circuit Breakers.
  - *Why*: The internet is not reliable. [cite_start]These patterns make your system robust and prevent costly mistakes[cite: 148].

- *4. Leaving a Clear Trail (Events & The Outbox Pattern)*
  - *What*: Recording every important business fact as an immutable "Domain Event" and using the Outbox pattern to guarantee these events are reliably published.
  - [cite_start]*Why*: It provides a perfect audit log and allows different parts of your system to be loosely coupled, reacting to events instead of being tied together with direct calls[cite: 1898, 1899].

- *5. Speaking the Business's Language (BDD & DDD)*
  - *What*: Writing tests (BDD) and code (DDD) using the vocabulary of the business domain, not just technical jargon.
  - *Why*: It closes the gap between engineers and business stakeholders, making the system's behavior clear and verifiable to everyone.
